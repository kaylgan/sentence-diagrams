2020Aug27 working script

Elements are draggable with correct cursor placement
Rotation, resize, alignment are working

// get sibling element offsets for each draggable
let getOffset = (function(lookup = null, set = false, myMap = {}) {
  let offsetMap = {};
  let offset = 0;
  console.log("top of getOffset");
  return function (lookupInner = lookup, setInner = set, mapInner = myMap) {
    console.log("bottom of getOffset with " + lookupInner);
    if (setInner == true) {
      offsetMap = mapInner;
      console.log("MAP set to");
      console.log(offsetMap);
    } else if (lookupInner) {
      console.log("getting value from map");
      offset = offsetMap.get(lookupInner);
      console.log("got value: " + offset);
    }
    return offset;
  }
})();

// add event listeners for draggables, slider, buttons
configureElements();

// get all elements to add listeners to them
function configureElements() {
  let elements = document.getElementsByClassName("draggable");
  arrangeElements(elements);

  for (let i = 0; i < elements.length; i++) {
    dragElement(elements[i]);
  }

  slider();
  buttons();
}

// align elements to siblings (absolute positioning for drag/drop)
function arrangeElements(elmntArray) {
  let offset = 0;

  let offsetMap = new Map();
  offsetMap.set(elmntArray[0], 0);
  // console.log(offsetMap);

  // start at 1; don't need to reposition first element
  for (let i = 1; i < elmntArray.length; i++) {
    offset += elmntArray[i].previousElementSibling.getBoundingClientRect().width;
    elmntArray[i].style.left = offset + 'px';
    offsetMap.set(elmntArray[i], offset);
    // elmntArray[i].innerHTML = offset;
    console.log("get: " + offsetMap.get(elmntArray[i]));
    console.log("arr: " + elmntArray[i].innerHTML + " offset: " + offset);
  }

  // save offsets
  getOffset(null, true, offsetMap);
  // console.log(getOffset(elmntArray[3]));
}

// set up slider
function slider() {
  let rangeslider = document.getElementById("lineSizeSlider");
  let rangeValue = document.getElementById("rangeValue");
  rangeslider.oninput = function() {
    let currentElement = lastSelectedElement();
    if (currentElement) {
      currentElement.style.width = this.value + 'px';
      console.log("in slider, current: " + currentElement);
      rangeValue.innerHTML = this.value;
    }
  }
}

// set up buttons
function buttons() {
  let myButtons = document.getElementsByClassName("menuBtn");
  for (let i = 0; i < myButtons.length; i++) {
    myButtons[i].addEventListener('click', function() {
      let btnText = myButtons[i].innerHTML;
      let currentElement = lastSelectedElement();
      if (btnText == "dashed" || btnText == "solid") {
        currentElement.style.borderBottomStyle = btnText;
      } else {
        currentElement.style.textAlign = btnText;
      }
    }, false);
  }
}

// get location of element
function findPos(element) {
  console.log("in findpos with " + element.innerHTML);
  let curleft = curtop = 0;
  let initialElement = element;
  console.log(element);
  if (element.offsetParent) {
    console.log("middle in findpos with " + element.innerHTML);
    do {
      curleft += element.offsetLeft;
      curtop += element.offsetTop;
    } while (element = element.offsetParent);
  }

  // add offset from element's siblings
  console.log(getOffset(initialElement));
  curleft -= getOffset(element);

  return { x: curleft, y: curtop };
}

// get the most recently dragged element
let lastSelectedElement = (function(set = false, setValue = null) {
  let currentElement = null;
  return function(setInner = set, setValueInner = setValue) {
    if (setInner === true) {

      if (currentElement) {
        // if a new element is dragged, deselect the previous element
        currentElement.style.borderColor = 'black';
      }

      if (setValueInner) {
        // update the currently selected element
        currentElement = setValueInner;
        // if a new element is dragged, select it
        currentElement.style.borderColor = 'lightgreen';
      } else {
        // if the window area is clicked, deselect the previous element
        currentElement.style.borderColor = 'black';
      }

    } else {
      // if set is false, just return the last element selected
      return currentElement;
    }
  }
})();

function deselectAll() {
  lastSelectedElement(true, null);
  console.log("in deselectAll");
}

// apply event listeners
function dragElement(elmnt) {
  let elementX = 0, elementY = 0, cursorX = 0, cursorY = 0;

  console.log("before findPos for " + elmnt.innerHTML);
  let pos = findPos(elmnt);
  elementX = pos.x;
  elementY = pos.y;
  let currentRotation = 0;

  window.addEventListener('dblclick', deselectAll, false);
  elmnt.addEventListener('mousedown', dragMouseDown, false);
  elmnt.addEventListener('dblclick', rotate, false);

  function dragMouseDown(e) {
    e.preventDefault();
    // elmnt.style.position = 'absolute';

    // set this element as the currently selected element
    lastSelectedElement(true, elmnt);
    console.log(lastSelectedElement());

    // get element's initial coordinates, accounting for parent offsets
    elementX = e.clientX - pos.x;
    elementY = e.clientY - pos.y;

    // get new cursor position
    cursorX = e.clientX;
    cursorY = e.clientY;

    window.addEventListener('mouseup', closeDragElement, false);
    window.addEventListener('mousemove', elementDrag, false);
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();

    // update element position
    elmnt.style.left = elementX + e.clientX - cursorX + 'px';
    elmnt.style.top = elementY + e.clientY - cursorY + 'px';
  }

  // stop moving when mouse button is released
  function closeDragElement() {
    window.removeEventListener('mouseup', closeDragElement, false);
    window.removeEventListener('mousemove', elementDrag, false);
  }

  // rotate element 45 degrees when double clicked
  function rotate() {
    elmnt.style.transformOrigin = 'left';
    currentRotation += 45;
    if (currentRotation == 360) {
      currentRotation = 0;
    }
    // 135 to 315
    if (currentRotation >= 135 && currentRotation < 270) {
      currentRotation = 270;
    }
    elmnt.style.transform = 'rotate(' + currentRotation + 'deg)';
  }
}
